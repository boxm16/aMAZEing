/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package amazeing;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import javax.swing.JTable;
import javax.swing.Timer;
import javax.swing.table.DefaultTableCellRenderer;

/**
 *
 * @author Michail Sitmalidis
 */
public class FRAME extends javax.swing.JFrame {

    /**
     * Creates new form FRAME
     */
    public FRAME() {
        initComponents();
        jTable1.setGridColor(Color.blue);
        jTable1.setShowHorizontalLines(true);
        jTable1.setShowVerticalLines(true);
        jTable1.setDefaultRenderer(Object.class, myRenderer);
        rows = jTable1.getRowCount();
        columns = jTable1.getColumnCount();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        startPoint_X = new javax.swing.JTextField();
        startPoint_Y = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        endPoint_X = new javax.swing.JTextField();
        endPoint_Y = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(153, 255, 153));

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4", "Title 5", "Title 6", "Title 7", "Title 8", "Title 9", "Title 10", "Title 11", "Title 12", "Title 13", "Title 14", "Title 15", "Title 16", "Title 17", "Title 18", "Title 19", "Title 20"
            }
        ));
        jTable1.setRowHeight(42);
        jScrollPane1.setViewportView(jTable1);

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("CLEAR PATH");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        startPoint_X.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        startPoint_X.setText("0");

        startPoint_Y.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        startPoint_Y.setText("0");

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        jLabel1.setText("Start Point:X");

        jLabel2.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        jLabel2.setText("Y");

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        jLabel3.setText("End Point:Y");

        jLabel4.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        jLabel4.setText("Y");

        endPoint_X.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        endPoint_X.setText("19");

        endPoint_Y.setFont(new java.awt.Font("Tahoma", 0, 40)); // NOI18N
        endPoint_Y.setText("19");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(startPoint_X, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(startPoint_Y, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(40, 40, 40)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(endPoint_X, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(endPoint_Y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(233, 233, 233)
                        .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 1280, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(startPoint_X)
                        .addComponent(jLabel2)
                        .addComponent(jLabel1)
                        .addComponent(startPoint_Y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel3)
                        .addComponent(endPoint_X, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel4)
                        .addComponent(endPoint_Y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, 55, Short.MAX_VALUE))
                    .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 885, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        int rows = jTable1.getRowCount();
        int columns = jTable1.getColumnCount();

        mat = new int[rows][columns];
        for (int a = 0; a < rows; a++) {
            for (int b = 0; b < columns; b++) {
                if (jTable1.getValueAt(a, b) != null) {
                    String spot = jTable1.getValueAt(a, b).toString();
                    if (spot.equals("")) {
                        mat[a][b] = 1;
                    } else {
                        mat[a][b] = 0;
                    }
                } else {
                    mat[a][b] = 1;
                }
            }
        }
        

        Point source = new Point(Integer.parseInt(startPoint_X.getText()), Integer.parseInt(startPoint_Y.getText()));
        Point dest = new Point(Integer.parseInt(endPoint_X.getText()), Integer.parseInt(endPoint_Y.getText()));

        dist = BFS(mat, source, dest);

        if (dist != Integer.MAX_VALUE) {
            System.out.println("Shortest Path is " + dist);
        } else {
            System.out.println("Shortest Path doesn't exist");
        }

        start_to_end = new ArrayList();
        for (QueueNode queueNode : path) {
            Point oldPoint = queueNode.getPoint();
            Point newPoint = new Point(oldPoint.getX(), oldPoint.getY());
            QueueNode newQN = new QueueNode(newPoint, queueNode.dist);
            start_to_end.add(newQN);
        }

        source = new Point(Integer.parseInt(endPoint_X.getText()), Integer.parseInt(endPoint_Y.getText()));
        dest = new Point(Integer.parseInt(startPoint_X.getText()), Integer.parseInt(startPoint_Y.getText()));

        BFS(mat, source, dest);

        end_to_start = new ArrayList();
        for (QueueNode queueNode : path) {
            Point oldPoint = queueNode.getPoint();
            Point newPoint = new Point(oldPoint.getX(), oldPoint.getY());
            QueueNode newQN = new QueueNode(newPoint, queueNode.dist);
            end_to_start.add(newQN);
        }

        pathX = findPathX(start_to_end, end_to_start);

        Timer timer = new Timer(1000, new PathStepTimer());

        // TODO add your handling code here:
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        int x = jTable1.getRowCount();
        int y = jTable1.getColumnCount();

        for (int n = 0; n < x; n++) {
            for (int m = 0; m < y; m++) {
                Object object = jTable1.getValueAt(n, m);
                if (object != null) {
                    String mark = object.toString();
                    if (mark.equals("0") || mark.equals("+")) {
                        jTable1.setValueAt("", n, m);
                    }
                }
            }
        }        // TODO add your handling code here:
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FRAME.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FRAME.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FRAME.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FRAME.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FRAME().setVisible(true);
            }
        });
    }
    private int rows;
    private int columns;
    private int mat[][];
    int dist;
    // These arrays are used to get row and column 
// numbers of 4 neighbours of a given cell 
    static int rowNum[] = {-1, 0, 0, 1};
    static int colNum[] = {0, -1, 1, 0};
    ArrayList<QueueNode> path;
    ArrayList<QueueNode> start_to_end;
    ArrayList<QueueNode> end_to_start;
    ArrayList<QueueNode> pathX;
    Queue<QueueNode> q;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField endPoint_X;
    private javax.swing.JTextField endPoint_Y;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextField startPoint_X;
    private javax.swing.JTextField startPoint_Y;
    // End of variables declaration//GEN-END:variables

    DefaultTableCellRenderer myRenderer = new DefaultTableCellRenderer() {
        @Override
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row, int col) {

            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, col);

            String status = (String) table.getModel().getValueAt(row, col);
            if ("x".equals(status)) {
                setBackground(Color.BLACK);
                setForeground(Color.BLACK);
            } else if ("0".equals(status)) {
                setBackground(Color.GREEN);
                setForeground(Color.GREEN);

            } else if ("Y".equals(status)) {
                setBackground(Color.BLUE);
                setForeground(Color.BLUE);
            } else if ("F".equals(status)) {
                setBackground(Color.YELLOW);
                setForeground(Color.YELLOW);

            } else if ("+".equals(status)) {
                setBackground(Color.RED);
                setForeground(Color.RED);
            } else {
                setBackground(table.getBackground());
                setForeground(table.getForeground());
            }
            return this;
        }
    };

    private int BFS(int[][] mat, Point src, Point dest) {

        // check source and destination cell 
        // of the matrix have value 1 
        if (mat[src.getX()][src.getY()] != 1
                || mat[dest.getX()][dest.getY()] != 1) {

            return -1;
        }

        boolean[][] visited = new boolean[rows][columns];

        // Mark the source cell as visited 
        visited[src.getX()][src.getY()] = true;

        path = new ArrayList();

        // Create a queue for BFS 
        q = new LinkedList<>();

        // Distance of source cell is 0 
        QueueNode s = new QueueNode(src, 0);
        q.add(s); // Enqueue source cell 
        path.add(s);
        // Do a BFS starting from source cell 
        while (!q.isEmpty()) {
            QueueNode curr = q.peek();
            Point pt = curr.getPoint();

            // If we have reached the destination cell, 
            // we are done 
            if (pt.getX() == dest.getX() && pt.getY() == dest.getY()) {

                return curr.dist;
            }

            // Otherwise dequeue the front cell 
            // in the queue and enqueue 
            // its adjacent cells 
            q.remove();

            for (int i = 0; i < 4; i++) {
                int row = pt.getX() + rowNum[i];
                int col = pt.getY() + colNum[i];

                // if adjacent cell is valid, has path 
                // and not visited yet, enqueue it. 
                if (isValid(row, col)
                        && mat[row][col] == 1
                        && !visited[row][col]) {
                    // mark cell as visited and enqueue it 
                    visited[row][col] = true;
                    QueueNode Adjcell = new QueueNode(new Point(row, col),
                            curr.dist + 1);
                    q.add(Adjcell);
                    path.add(Adjcell);
                }
            }
        }

        // Return -1 if destination cannot be reached 
        return -1;

    }

    private boolean isValid(int row, int col) {
        // return true if row number and 
        // column number is in range 
        return (row >= 0) && (row < rows)
                && (col >= 0) && (col < columns);

    }

    private ArrayList<QueueNode> findPathX(ArrayList<QueueNode> start_to_end, ArrayList<QueueNode> end_to_start) {
        ArrayList<QueueNode> pathX = new ArrayList();

        for (QueueNode QN : start_to_end) {
            for (QueueNode qn : end_to_start) {
                if (QN.getPoint().getX() == qn.getPoint().getX() && QN.getPoint().getY() == qn.getPoint().getY()) {
                    if (QN.dist + qn.dist == dist) {
                        jTable1.setValueAt("0", qn.getPoint().getX(), qn.getPoint().getY());

                    }
                }
            }

        }

        return pathX;
    }

    private static class PathStepTimer implements ActionListener {

        public PathStepTimer() {
        }

        @Override
        public void actionPerformed(ActionEvent e) {

        }
    }

}
